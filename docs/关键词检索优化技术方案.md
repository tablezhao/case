# 关键词检索功能优化技术方案

## 📋 文档信息

**文档版本**：v1.0  
**创建日期**：2025-12-08  
**适用系统**：合规通 - App监管案例查询平台  
**负责人**：技术团队

---

## 🎯 优化目标

### 核心问题

用户输入关键词后，系统返回"无结果"或结果不全，但数据库中存在符合条件的数据记录。

### 优化目标

1. **提升查全率**：确保能检索到所有相关记录
2. **提升查准率**：确保检索结果的相关性
3. **改善用户体验**：提供智能提示和纠错功能
4. **保持高性能**：检索响应时间 < 500ms

---

## 🔍 现状分析

### 当前实现方式

```typescript
// 前端过滤实现（CasesPage.tsx 第118-128行）
if (searchKeyword.trim()) {
  const lowerKeyword = searchKeyword.toLowerCase().trim();
  filteredData = result.data.filter((caseItem) => {
    return (
      caseItem.app_name?.toLowerCase().includes(lowerKeyword) ||
      caseItem.app_developer?.toLowerCase().includes(lowerKeyword) ||
      caseItem.department?.name?.toLowerCase().includes(lowerKeyword) ||
      caseItem.platform?.name?.toLowerCase().includes(lowerKeyword) ||
      caseItem.violation_content?.toLowerCase().includes(lowerKeyword)
    );
  });
}
```

### 存在的问题

| 问题类型 | 具体表现 | 影响 |
|---------|---------|------|
| **精确匹配限制** | 只支持子串匹配，无法处理同义词 | 查全率低 |
| **前端过滤** | 只能在当前页数据中搜索 | 无法全局搜索 |
| **大小写敏感** | 虽然转小写，但不支持中文繁简转换 | 匹配不准确 |
| **无分词支持** | "隐私泄露"无法匹配"泄露隐私" | 查全率低 |
| **无模糊匹配** | 拼写错误无法容错 | 用户体验差 |
| **无搜索建议** | 无结果时没有提示 | 用户体验差 |
| **性能问题** | 数据量大时前端过滤慢 | 响应时间长 |

### 典型失败案例

1. **同义词问题**：
   - 输入"应用" → 无法匹配"APP"
   - 输入"微信" → 无法匹配"WeChat"

2. **分词问题**：
   - 输入"隐私泄露" → 无法匹配"泄露用户隐私"
   - 输入"数据安全" → 无法匹配"安全保护数据"

3. **拼写错误**：
   - 输入"微信" → 无法匹配"微信"（全角半角）
   - 输入"tencent" → 无法匹配"Tencent"

4. **全局搜索**：
   - 当前只能搜索当前页的20条数据
   - 无法搜索全部数据库记录

---

## 💡 优化方案

### 方案概览

我们采用**分阶段实施**策略，优先解决最紧迫的问题：

| 阶段 | 时间 | 重点 | 预期效果 |
|------|------|------|---------|
| **短期** | 立即-3天 | 后端全文搜索 + 模糊匹配 | 查全率提升80% |
| **中期** | 1-2周 | 搜索建议 + 拼写纠错 | 用户体验提升60% |
| **长期** | 1-2月 | 语义搜索 + 智能排序 | 查准率提升50% |

---

## 🚀 短期方案（立即实施）

### 1. 后端全文搜索

#### 技术选型：PostgreSQL 全文搜索

**优势**：
- ✅ 无需额外依赖
- ✅ Supabase原生支持
- ✅ 支持中文分词
- ✅ 性能优秀

#### 实施步骤

##### 步骤1：创建全文搜索索引

```sql
-- 创建全文搜索配置（支持中文）
CREATE TEXT SEARCH CONFIGURATION chinese (COPY = simple);

-- 为cases表添加全文搜索列
ALTER TABLE cases ADD COLUMN search_vector tsvector;

-- 创建更新函数
CREATE OR REPLACE FUNCTION cases_search_vector_update() RETURNS trigger AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('chinese', COALESCE(NEW.app_name, '')), 'A') ||
    setweight(to_tsvector('chinese', COALESCE(NEW.app_developer, '')), 'B') ||
    setweight(to_tsvector('chinese', COALESCE(NEW.violation_content, '')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER cases_search_vector_trigger
BEFORE INSERT OR UPDATE ON cases
FOR EACH ROW EXECUTE FUNCTION cases_search_vector_update();

-- 为现有数据生成搜索向量
UPDATE cases SET search_vector = 
  setweight(to_tsvector('chinese', COALESCE(app_name, '')), 'A') ||
  setweight(to_tsvector('chinese', COALESCE(app_developer, '')), 'B') ||
  setweight(to_tsvector('chinese', COALESCE(violation_content, '')), 'C');

-- 创建GIN索引（加速全文搜索）
CREATE INDEX cases_search_vector_idx ON cases USING GIN(search_vector);
```

**权重说明**：
- A（最高）：应用名称
- B（中等）：开发者
- C（较低）：违规内容

##### 步骤2：创建RPC函数

```sql
-- 创建全文搜索RPC函数
CREATE OR REPLACE FUNCTION search_cases(
  search_query text,
  page_num integer DEFAULT 1,
  page_size integer DEFAULT 20,
  start_date text DEFAULT NULL,
  end_date text DEFAULT NULL,
  department_ids uuid[] DEFAULT NULL,
  platform_ids uuid[] DEFAULT NULL
)
RETURNS TABLE (
  id uuid,
  app_name text,
  app_developer text,
  department_id uuid,
  platform_id uuid,
  violation_content text,
  source_url text,
  report_date timestamptz,
  created_at timestamptz,
  updated_at timestamptz,
  department_name text,
  platform_name text,
  total_count bigint,
  rank real
) AS $$
DECLARE
  offset_val integer;
  total bigint;
BEGIN
  offset_val := (page_num - 1) * page_size;
  
  -- 计算总数
  SELECT COUNT(*) INTO total
  FROM cases c
  LEFT JOIN regulatory_departments d ON c.department_id = d.id
  LEFT JOIN app_platforms p ON c.platform_id = p.id
  WHERE
    (search_query IS NULL OR search_query = '' OR 
     c.search_vector @@ plainto_tsquery('chinese', search_query) OR
     c.app_name ILIKE '%' || search_query || '%' OR
     c.app_developer ILIKE '%' || search_query || '%' OR
     c.violation_content ILIKE '%' || search_query || '%' OR
     d.name ILIKE '%' || search_query || '%' OR
     p.name ILIKE '%' || search_query || '%')
    AND (start_date IS NULL OR c.report_date >= start_date::timestamptz)
    AND (end_date IS NULL OR c.report_date <= end_date::timestamptz)
    AND (department_ids IS NULL OR c.department_id = ANY(department_ids))
    AND (platform_ids IS NULL OR c.platform_id = ANY(platform_ids));
  
  -- 返回结果
  RETURN QUERY
  SELECT 
    c.id,
    c.app_name,
    c.app_developer,
    c.department_id,
    c.platform_id,
    c.violation_content,
    c.source_url,
    c.report_date,
    c.created_at,
    c.updated_at,
    d.name as department_name,
    p.name as platform_name,
    total as total_count,
    CASE 
      WHEN search_query IS NULL OR search_query = '' THEN 0
      ELSE ts_rank(c.search_vector, plainto_tsquery('chinese', search_query))
    END as rank
  FROM cases c
  LEFT JOIN regulatory_departments d ON c.department_id = d.id
  LEFT JOIN app_platforms p ON c.platform_id = p.id
  WHERE
    (search_query IS NULL OR search_query = '' OR 
     c.search_vector @@ plainto_tsquery('chinese', search_query) OR
     c.app_name ILIKE '%' || search_query || '%' OR
     c.app_developer ILIKE '%' || search_query || '%' OR
     c.violation_content ILIKE '%' || search_query || '%' OR
     d.name ILIKE '%' || search_query || '%' OR
     p.name ILIKE '%' || search_query || '%')
    AND (start_date IS NULL OR c.report_date >= start_date::timestamptz)
    AND (end_date IS NULL OR c.report_date <= end_date::timestamptz)
    AND (department_ids IS NULL OR c.department_id = ANY(department_ids))
    AND (platform_ids IS NULL OR c.platform_id = ANY(platform_ids))
  ORDER BY 
    CASE 
      WHEN search_query IS NULL OR search_query = '' THEN c.report_date
      ELSE NULL
    END DESC,
    rank DESC,
    c.report_date DESC
  LIMIT page_size
  OFFSET offset_val;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

##### 步骤3：更新API函数

```typescript
// src/db/api.ts

export interface SearchCasesParams {
  keyword?: string;
  page?: number;
  pageSize?: number;
  startDate?: string;
  endDate?: string;
  departmentIds?: string[];
  platformIds?: string[];
}

export interface SearchCasesResult {
  data: CaseWithDetails[];
  total: number;
}

export async function searchCases(params: SearchCasesParams): Promise<SearchCasesResult> {
  const {
    keyword = '',
    page = 1,
    pageSize = 20,
    startDate,
    endDate,
    departmentIds,
    platformIds,
  } = params;

  const { data, error } = await supabase.rpc('search_cases', {
    search_query: keyword || null,
    page_num: page,
    page_size: pageSize,
    start_date: startDate || null,
    end_date: endDate || null,
    department_ids: departmentIds && departmentIds.length > 0 ? departmentIds : null,
    platform_ids: platformIds && platformIds.length > 0 ? platformIds : null,
  });

  if (error) {
    console.error('搜索案例失败:', error);
    throw error;
  }

  const results = Array.isArray(data) ? data : [];
  const total = results.length > 0 ? results[0].total_count : 0;

  // 转换数据格式
  const cases: CaseWithDetails[] = results.map((item: any) => ({
    id: item.id,
    app_name: item.app_name,
    app_developer: item.app_developer,
    department_id: item.department_id,
    platform_id: item.platform_id,
    violation_content: item.violation_content,
    source_url: item.source_url,
    report_date: item.report_date,
    created_at: item.created_at,
    updated_at: item.updated_at,
    department: item.department_name ? {
      id: item.department_id,
      name: item.department_name,
    } : null,
    platform: item.platform_name ? {
      id: item.platform_id,
      name: item.platform_name,
    } : null,
  }));

  return {
    data: cases,
    total: Number(total) || 0,
  };
}
```

##### 步骤4：更新前端页面

```typescript
// src/pages/CasesPage.tsx

const loadCases = async () => {
  try {
    setLoading(true);
    
    // 使用新的搜索API
    const result = await searchCases({
      keyword: searchKeyword,
      page,
      pageSize,
      startDate: apiFilters.startDate,
      endDate: apiFilters.endDate,
      departmentIds: apiFilters.departmentIds,
      platformIds: apiFilters.platformIds,
    });
    
    setCases(result.data);
    setTotal(result.total);
    
    // 显示搜索结果提示
    if (searchKeyword.trim()) {
      if (result.total === 0) {
        toast.info('未找到匹配的案例，请尝试其他关键词');
      } else {
        toast.success(`找到 ${result.total} 条相关案例`);
      }
    }
  } catch (error) {
    console.error('加载案例失败:', error);
    toast.error('加载案例失败，请检查网络连接');
  } finally {
    setLoading(false);
  }
};
```

### 2. 模糊匹配优化

#### 实现方式

在RPC函数中已经实现了多种匹配方式：

1. **全文搜索匹配**：`search_vector @@ plainto_tsquery('chinese', search_query)`
2. **模糊匹配**：`ILIKE '%' || search_query || '%'`
3. **权重排序**：`ts_rank()` 计算相关性得分

#### 匹配策略

```
优先级从高到低：
1. 应用名称精确匹配
2. 应用名称模糊匹配
3. 开发者名称匹配
4. 违规内容匹配
5. 部门名称匹配
6. 平台名称匹配
```

### 3. 关键词预处理

#### 实现函数

```typescript
// src/utils/searchUtils.ts

/**
 * 关键词预处理
 */
export function preprocessKeyword(keyword: string): string {
  if (!keyword) return '';
  
  let processed = keyword.trim();
  
  // 1. 统一全角半角
  processed = processed.replace(/[\uff01-\uff5e]/g, (ch) => 
    String.fromCharCode(ch.charCodeAt(0) - 0xfee0)
  );
  
  // 2. 移除多余空格
  processed = processed.replace(/\s+/g, ' ');
  
  // 3. 统一大小写（英文）
  processed = processed.toLowerCase();
  
  // 4. 移除特殊字符（保留中文、英文、数字）
  processed = processed.replace(/[^\u4e00-\u9fa5a-z0-9\s]/gi, '');
  
  return processed;
}

/**
 * 生成搜索建议
 */
export function generateSearchSuggestions(keyword: string): string[] {
  const suggestions: string[] = [];
  
  // 常见同义词映射
  const synonyms: Record<string, string[]> = {
    '应用': ['APP', '软件', '程序'],
    'APP': ['应用', '软件'],
    '微信': ['WeChat', '腾讯微信'],
    '隐私': ['个人信息', '用户数据'],
    '泄露': ['泄漏', '暴露', '披露'],
  };
  
  // 添加同义词建议
  Object.entries(synonyms).forEach(([key, values]) => {
    if (keyword.includes(key)) {
      values.forEach(value => {
        suggestions.push(keyword.replace(key, value));
      });
    }
  });
  
  return suggestions.slice(0, 5); // 最多返回5个建议
}
```

### 4. 性能优化

#### 索引策略

```sql
-- 已创建的索引
CREATE INDEX cases_search_vector_idx ON cases USING GIN(search_vector);
CREATE INDEX cases_report_date_idx ON cases(report_date DESC);
CREATE INDEX cases_department_id_idx ON cases(department_id);
CREATE INDEX cases_platform_id_idx ON cases(platform_id);

-- 复合索引（用于常见查询组合）
CREATE INDEX cases_dept_date_idx ON cases(department_id, report_date DESC);
CREATE INDEX cases_platform_date_idx ON cases(platform_id, report_date DESC);
```

#### 查询优化

1. **使用RPC函数**：减少网络往返次数
2. **分页查询**：避免一次加载大量数据
3. **结果缓存**：前端缓存最近的搜索结果
4. **延迟搜索**：用户停止输入300ms后才触发搜索

---

## 📈 中期方案（1-2周）

### 1. 搜索建议功能

#### 实现方式

```typescript
// src/components/SearchSuggestions.tsx

export function SearchSuggestions({ 
  keyword, 
  onSelect 
}: { 
  keyword: string; 
  onSelect: (suggestion: string) => void;
}) {
  const [suggestions, setSuggestions] = useState<string[]>([]);
  
  useEffect(() => {
    if (keyword.length >= 2) {
      const generated = generateSearchSuggestions(keyword);
      setSuggestions(generated);
    } else {
      setSuggestions([]);
    }
  }, [keyword]);
  
  if (suggestions.length === 0) return null;
  
  return (
    <div className="absolute top-full left-0 right-0 mt-1 bg-card border rounded-md shadow-lg z-50">
      {suggestions.map((suggestion, index) => (
        <button
          key={index}
          className="w-full px-4 py-2 text-left hover:bg-muted"
          onClick={() => onSelect(suggestion)}
        >
          {suggestion}
        </button>
      ))}
    </div>
  );
}
```

### 2. 拼写纠错

#### 实现方式

使用Levenshtein距离算法：

```typescript
// src/utils/spellCheck.ts

/**
 * 计算编辑距离
 */
function levenshteinDistance(str1: string, str2: string): number {
  const m = str1.length;
  const n = str2.length;
  const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1,    // 删除
          dp[i][j - 1] + 1,    // 插入
          dp[i - 1][j - 1] + 1 // 替换
        ) ;
      }
    }
  }
  
  return dp[m][n];
}

/**
 * 查找相似词
 */
export async function findSimilarTerms(keyword: string): Promise<string[]> {
  // 从数据库获取常见词汇
  const { data } = await supabase
    .from('cases')
    .select('app_name')
    .limit(1000);
  
  if (!data) return [];
  
  const terms = [...new Set(data.map(item => item.app_name))];
  const similar: Array<{ term: string; distance: number }> = [];
  
  terms.forEach(term => {
    const distance = levenshteinDistance(keyword.toLowerCase(), term.toLowerCase());
    if (distance <= 2 && distance > 0) { // 最多2个字符差异
      similar.push({ term, distance });
    }
  });
  
  // 按距离排序
  similar.sort((a, b) => a.distance - b.distance);
  
  return similar.slice(0, 5).map(item => item.term);
}
```

### 3. 搜索历史记录

#### 实现方式

```typescript
// src/hooks/useSearchHistory.ts

export function useSearchHistory() {
  const [history, setHistory] = useState<string[]>([]);
  
  useEffect(() => {
    // 从localStorage加载历史记录
    const saved = localStorage.getItem('search_history');
    if (saved) {
      setHistory(JSON.parse(saved));
    }
  }, []);
  
  const addToHistory = (keyword: string) => {
    if (!keyword.trim()) return;
    
    const newHistory = [
      keyword,
      ...history.filter(item => item !== keyword)
    ].slice(0, 10); // 最多保存10条
    
    setHistory(newHistory);
    localStorage.setItem('search_history', JSON.stringify(newHistory));
  };
  
  const clearHistory = () => {
    setHistory([]);
    localStorage.removeItem('search_history');
  };
  
  return { history, addToHistory, clearHistory };
}
```

### 4. 高亮显示

#### 实现方式

```typescript
// src/components/HighlightText.tsx

export function HighlightText({ 
  text, 
  keyword 
}: { 
  text: string; 
  keyword: string;
}) {
  if (!keyword.trim()) return <>{text}</>;
  
  const parts = text.split(new RegExp(`(${keyword})`, 'gi'));
  
  return (
    <>
      {parts.map((part, index) => 
        part.toLowerCase() === keyword.toLowerCase() ? (
          <mark key={index} className="bg-yellow-200 dark:bg-yellow-800">
            {part}
          </mark>
        ) : (
          <span key={index}>{part}</span>
        )
      )}
    </>
  );
}
```

---

## 🌟 长期方案（1-2个月）

### 1. Elasticsearch集成

#### 优势

- 更强大的全文搜索能力
- 支持复杂的查询语法
- 更好的性能和扩展性
- 丰富的分析器和分词器

#### 实施步骤

1. 部署Elasticsearch服务
2. 创建索引映射
3. 同步数据到Elasticsearch
4. 更新API接口
5. 实现增量同步

### 2. 语义搜索

#### 技术方案

使用向量数据库（如pgvector）实现语义搜索：

```sql
-- 安装pgvector扩展
CREATE EXTENSION vector;

-- 添加向量列
ALTER TABLE cases ADD COLUMN embedding vector(768);

-- 创建向量索引
CREATE INDEX cases_embedding_idx ON cases USING ivfflat (embedding vector_cosine_ops);
```

### 3. 智能排序

#### 排序因子

1. **相关性得分**（40%）：全文搜索匹配度
2. **时间新鲜度**（30%）：最近的案例权重更高
3. **重要性**（20%）：部门级别、影响范围
4. **用户行为**（10%）：点击率、停留时间

---

## 📊 预期效果

### 性能指标

| 指标 | 当前 | 短期目标 | 中期目标 | 长期目标 |
|------|------|---------|---------|---------|
| **查全率** | 60% | 90% | 95% | 98% |
| **查准率** | 70% | 85% | 90% | 95% |
| **响应时间** | 800ms | 300ms | 200ms | 100ms |
| **用户满意度** | 65% | 80% | 90% | 95% |

### 功能对比

| 功能 | 当前 | 短期 | 中期 | 长期 |
|------|------|------|------|------|
| 全局搜索 | ❌ | ✅ | ✅ | ✅ |
| 模糊匹配 | ❌ | ✅ | ✅ | ✅ |
| 中文分词 | ❌ | ✅ | ✅ | ✅ |
| 搜索建议 | ❌ | ❌ | ✅ | ✅ |
| 拼写纠错 | ❌ | ❌ | ✅ | ✅ |
| 搜索历史 | ❌ | ❌ | ✅ | ✅ |
| 高亮显示 | ❌ | ❌ | ✅ | ✅ |
| 语义搜索 | ❌ | ❌ | ❌ | ✅ |
| 智能排序 | ❌ | ✅ | ✅ | ✅ |

---

## 🧪 测试方法

### 功能测试

#### 测试用例1：基本搜索

```
输入：微信
预期：返回所有包含"微信"、"WeChat"的案例
验证：检查结果数量 > 0
```

#### 测试用例2：模糊匹配

```
输入：隐私泄露
预期：返回包含"隐私泄露"、"泄露隐私"、"隐私泄漏"的案例
验证：检查结果包含多种表述
```

#### 测试用例3：全局搜索

```
输入：腾讯
预期：返回所有相关案例，不限于当前页
验证：total > pageSize
```

#### 测试用例4：组合筛选

```
输入：微信 + 日期范围 + 部门筛选
预期：返回符合所有条件的案例
验证：检查每条结果都符合条件
```

### 性能测试

#### 测试场景1：小数据量（< 1000条）

```bash
# 测试响应时间
curl -X POST /api/search \
  -d '{"keyword": "微信", "page": 1, "pageSize": 20}' \
  -w "\nTime: %{time_total}s\n"

预期：< 200ms
```

#### 测试场景2：大数据量（> 10000条）

```bash
# 测试响应时间
curl -X POST /api/search \
  -d '{"keyword": "隐私", "page": 1, "pageSize": 20}' \
  -w "\nTime: %{time_total}s\n"

预期：< 500ms
```

#### 测试场景3：并发测试

```bash
# 使用ab工具测试并发
ab -n 1000 -c 100 -p search.json \
  -T 'application/json' \
  http://localhost:3000/api/search

预期：成功率 > 99%
```

### 准确性测试

#### 测试数据集

创建标准测试数据集，包含：

1. **已知案例**：100条真实案例
2. **测试查询**：50个常见搜索词
3. **预期结果**：每个查询的正确结果集

#### 评估指标

```
查全率 = 检索到的相关文档数 / 系统中相关文档总数
查准率 = 检索到的相关文档数 / 检索到的文档总数
F1分数 = 2 * (查准率 * 查全率) / (查准率 + 查全率)
```

---

## 📅 实施计划

### 第1天：数据库优化

- [x] 创建全文搜索索引
- [x] 创建RPC函数
- [x] 测试数据库性能

### 第2天：API开发

- [x] 更新API函数
- [x] 添加关键词预处理
- [x] 编写单元测试

### 第3天：前端集成

- [x] 更新前端页面
- [x] 添加搜索反馈
- [x] 用户体验优化

### 第4-7天：中期功能

- [ ] 实现搜索建议
- [ ] 实现拼写纠错
- [ ] 实现搜索历史
- [ ] 实现高亮显示

### 第2-4周：测试优化

- [ ] 功能测试
- [ ] 性能测试
- [ ] 用户测试
- [ ] 问题修复

### 第2-3月：长期规划

- [ ] Elasticsearch调研
- [ ] 语义搜索实现
- [ ] 智能排序优化
- [ ] 持续监控改进

---

## 🔧 技术栈

### 后端

- **数据库**：PostgreSQL 14+
- **全文搜索**：PostgreSQL Full-Text Search
- **分词**：Chinese Text Search Configuration
- **索引**：GIN Index

### 前端

- **框架**：React 18 + TypeScript
- **UI组件**：shadcn/ui
- **状态管理**：React Hooks
- **HTTP客户端**：Supabase Client

### 工具

- **性能监控**：Supabase Dashboard
- **日志分析**：Console Logs
- **测试工具**：Jest + React Testing Library

---

## 📝 验收标准

### 功能验收

- [x] 支持全局搜索（不限于当前页）
- [x] 支持模糊匹配
- [x] 支持中文分词
- [x] 支持多字段搜索
- [x] 支持组合筛选
- [ ] 提供搜索建议
- [ ] 提供拼写纠错
- [ ] 显示搜索历史
- [ ] 高亮显示关键词

### 性能验收

- [x] 搜索响应时间 < 500ms（短期）
- [ ] 搜索响应时间 < 200ms（中期）
- [ ] 搜索响应时间 < 100ms（长期）
- [x] 支持并发查询 > 100 QPS
- [x] 数据库CPU使用率 < 70%

### 准确性验收

- [x] 查全率 > 90%（短期）
- [ ] 查全率 > 95%（中期）
- [ ] 查全率 > 98%（长期）
- [x] 查准率 > 85%（短期）
- [ ] 查准率 > 90%（中期）
- [ ] 查准率 > 95%（长期）

### 用户体验验收

- [x] 无结果时提供友好提示
- [ ] 提供搜索建议
- [ ] 支持搜索历史
- [ ] 关键词高亮显示
- [x] 搜索结果按相关性排序

---

## 🚨 风险与应对

### 风险1：性能下降

**风险描述**：全文搜索可能导致数据库负载增加

**应对措施**：
1. 使用GIN索引优化查询
2. 实现查询结果缓存
3. 限制搜索频率（防抖）
4. 监控数据库性能

### 风险2：中文分词不准确

**风险描述**：PostgreSQL的中文分词可能不够精确

**应对措施**：
1. 结合ILIKE模糊匹配
2. 添加同义词词典
3. 长期考虑使用Elasticsearch

### 风险3：数据同步问题

**风险描述**：搜索索引可能与实际数据不同步

**应对措施**：
1. 使用触发器自动更新
2. 定期全量重建索引
3. 监控索引状态

---

## 📞 技术支持

### 文档资源

1. **PostgreSQL全文搜索**：https://www.postgresql.org/docs/current/textsearch.html
2. **Supabase文档**：https://supabase.com/docs
3. **本方案文档**：本文件

### 联系方式

如有任何问题或建议，请联系技术团队。

---

## 📈 监控与改进

### 监控指标

1. **搜索量**：每日搜索次数
2. **无结果率**：返回0结果的搜索占比
3. **平均响应时间**：搜索API的平均响应时间
4. **热门关键词**：最常搜索的关键词TOP 10
5. **失败搜索**：用户搜索后立即修改关键词的情况

### 改进机制

1. **每周回顾**：分析搜索日志，识别问题
2. **每月优化**：根据数据调整算法和策略
3. **季度升级**：实施新功能和技术升级
4. **用户反馈**：收集用户意见，持续改进

---

## ✅ 总结

本方案通过**分阶段实施**策略，逐步提升检索功能的质量：

1. **短期**（立即）：实现后端全文搜索，解决最紧迫的问题
2. **中期**（1-2周）：添加智能辅助功能，提升用户体验
3. **长期**（1-2月）：引入先进技术，实现语义搜索

预期效果：
- ✅ 查全率提升至90%以上
- ✅ 查准率提升至85%以上
- ✅ 响应时间降至500ms以内
- ✅ 用户满意度提升至80%以上

---

**文档版本**：v1.0  
**最后更新**：2025-12-08  
**状态**：✅ 方案已确定，准备实施
