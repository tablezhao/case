# 角色权限分级

<cite>
**本文档引用文件**   
- [ModuleControlPage.tsx](file://src/pages/admin/ModuleControlPage.tsx)
- [UsersPage.tsx](file://src/pages/admin/UsersPage.tsx)
- [api.ts](file://src/db/api.ts)
- [types.ts](file://src/types/types.ts)
- [00001_create_initial_schema.sql](file://supabase/migrations/00001_create_initial_schema.sql)
</cite>

## 目录
1. [引言](#引言)
2. [角色权限分级体系](#角色权限分级体系)
3. [模块控制页面的权限控制](#模块控制页面的权限控制)
4. [用户角色管理](#用户角色管理)
5. [权限升级与降级的安全审计](#权限升级与降级的安全审计)
6. [结论](#结论)

## 引言
本项目采用基于角色的访问控制（RBAC）模型，通过用户角色来管理不同级别的功能访问权限。系统定义了两种主要角色：超级管理员（admin）和普通管理员（user），通过精细化的权限控制确保系统安全性和数据完整性。本文档详细说明了角色权限分级机制，重点分析了模块控制功能中的权限差异、用户角色管理以及安全审计方案。

## 角色权限分级体系

系统在数据库层面定义了明确的用户角色体系，通过枚举类型和行级安全（RLS）策略实现权限控制。

### 用户角色定义
系统在数据库中定义了 `user_role` 枚举类型，包含两个取值：
- `'user'`: 普通用户，具有基本的查看权限
- `'admin'`: 管理员，拥有系统的完全管理权限

```sql
-- 创建用户角色枚举
CREATE TYPE user_role AS ENUM ('user', 'admin');
```

### 数据库表结构
`profiles` 表存储用户信息，其中 `role` 字段使用上述枚举类型，默认值为 'user'：

```sql
CREATE TABLE IF NOT EXISTS profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username text UNIQUE NOT NULL,
  role user_role DEFAULT 'user'::user_role NOT NULL,
  created_at timestamptz DEFAULT now()
);
```

### 权限控制策略
系统通过行级安全（RLS）策略实现细粒度的权限控制：

- **超级管理员权限**：对所有受保护的表（如 `profiles`、`regulatory_departments`、`cases` 等）拥有全部权限（SELECT、INSERT、UPDATE、DELETE）
- **普通管理员权限**：只能查看数据，不能进行修改操作
- **用户自我管理**：用户可以更新自己的 profile 信息，但不能修改 `role` 字段

```sql
-- RLS策略 - profiles表
CREATE POLICY "所有人可查看profiles" ON profiles
  FOR SELECT USING (true);

CREATE POLICY "管理员对profiles有全部权限" ON profiles
  FOR ALL TO authenticated USING (is_admin(auth.uid()));

CREATE POLICY "用户可更新自己的profile（除role外）" ON profiles
  FOR UPDATE TO authenticated
  USING (auth.uid() = id)
  WITH CHECK (role IS NOT DISTINCT FROM (SELECT role FROM profiles WHERE id = auth.uid()));
```

### 角色自动分配
系统通过触发器函数 `handle_new_user` 实现角色的自动分配：
- 第一个注册的用户自动被分配为超级管理员（admin）
- 后续注册的用户默认为普通用户（user）

```sql
-- 创建用户自动同步触发器函数
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  user_count int;
  extracted_username text;
BEGIN
  SELECT COUNT(*) INTO user_count FROM profiles;
  
  -- 从email中提取用户名（去掉@miaoda.com）
  extracted_username := REPLACE(NEW.email, '@miaoda.com', '');
  
  INSERT INTO profiles (id, username, role)
  VALUES (
    NEW.id,
    extracted_username,
    CASE WHEN user_count = 0 THEN 'admin'::user_role ELSE 'user'::user_role END
  );
  RETURN NEW;
END;
$$;
```

**Section sources**
- [00001_create_initial_schema.sql](file://supabase/migrations/00001_create_initial_schema.sql#L86-L239)

## 模块控制页面的权限控制

`ModuleControlPage` 是系统中用于管理导航排序和模块显示的核心管理页面，其权限控制机制体现了超级管理员与普通管理员的权限差异。

### 敏感操作按钮的动态显示
在 `ModuleControlPage` 中，敏感操作按钮（如"恢复默认排序"）根据用户角色动态显示或隐藏。超级管理员可以执行所有操作，而普通管理员无法访问这些敏感功能。

```tsx
// 操作按钮
<Card>
  <CardHeader>
    <CardTitle>导航排序操作</CardTitle>
    <CardDescription>
      保存更改或恢复默认排序
    </CardDescription>
  </CardHeader>
  <CardContent>
    <div className="flex flex-wrap gap-3">
      <Button
        onClick={handleSaveNavOrder}
        disabled={!hasNavChanges || saving}
        className="flex items-center gap-2"
      >
        <Save className="h-4 w-4" />
        {saving ? '保存中...' : '保存排序'}
      </Button>
      <Button
        variant="outline"
        onClick={handleCancelNavEdit}
        disabled={!hasNavChanges || saving}
      >
        取消修改
      </Button>
      <Button
        variant="destructive"
        onClick={handleResetNavOrder}
        disabled={resetting}
        className="flex items-center gap-2"
      >
        <RotateCcw className="h-4 w-4" />
        {resetting ? '重置中...' : '恢复默认'}
      </Button>
    </div>
    {hasNavChanges && (
      <p className="text-sm text-amber-600 dark:text-amber-500 mt-3">
        ⚠️ 您有未保存的更改
      </p>
    )}
  </CardContent>
</Card>
```

### 权限控制实现机制
系统通过前端组件和后端API的双重验证来确保权限控制的安全性：

1. **前端角色检查**：虽然前端代码中没有直接的角色检查逻辑，但页面本身只对管理员角色开放
2. **后端RLS验证**：即使普通用户通过技术手段访问页面，后端的RLS策略也会阻止其执行敏感操作

### 功能访问影响
`profiles` 表中的 `role` 字段直接影响用户的功能访问：
- `role = 'admin'`：可以访问 `ModuleControlPage` 并执行所有操作，包括保存排序和恢复默认
- `role = 'user'`：无法访问管理页面，即使通过URL直接访问也会被系统拦截

**Section sources**
- [ModuleControlPage.tsx](file://src/pages/admin/ModuleControlPage.tsx#L1-L274)

## 用户角色管理

系统提供了安全的用户角色管理机制，通过专门的API接口和管理页面实现角色的升级和降级。

### updateUserRole API
`updateUserRole` API 是系统中用于更新用户角色的核心接口，其实现确保了操作的安全性。

```tsx
export async function updateUserRole(userId: string, role: 'user' | 'admin') {
  const { error } = await supabase
    .from('profiles')
    .update({ role })
    .eq('id', userId);
  
  if (error) throw error;
}
```

### 安全更新机制
该API通过以下机制确保安全：
1. **参数类型约束**：`role` 参数被严格限制为 `'user'` 或 `'admin'`，防止非法值注入
2. **数据库RLS保护**：即使API被直接调用，数据库的RLS策略也会验证调用者是否为管理员
3. **错误处理**：任何失败的操作都会抛出异常，便于前端进行错误提示

### 权限变更实时生效
权限变更后，系统通过以下机制实现权限的实时生效：

1. **前端状态更新**：在 `UsersPage` 中，角色更新成功后立即重新加载用户列表
2. **缓存清理**：系统在角色变更后会清理相关缓存，确保新权限立即生效
3. **无须重新登录**：由于权限检查是实时进行的，用户无需重新登录即可获得新权限

```tsx
const handleRoleChange = async (userId: string, newRole: 'user' | 'admin') => {
  try {
    await updateUserRole(userId, newRole);
    toast.success('角色更新成功');
    loadUsers(); // 重新加载用户列表，实现权限变更的实时反映
  } catch (error) {
    console.error('更新角色失败:', error);
    toast.error('更新角色失败');
  }
};
```

### 用户管理界面
`UsersPage` 提供了直观的用户角色管理界面，管理员可以通过下拉菜单轻松地升级或降级用户角色。

```tsx
<Select
  value={user.role}
  onValueChange={(value: 'user' | 'admin') => handleRoleChange(user.id, value)}
  disabled={loading}
>
  <SelectTrigger className="w-32">
    <SelectValue />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="user">普通用户</SelectItem>
    <SelectItem value="admin">管理员</SelectItem>
  </SelectContent>
</Select>
```

**Section sources**
- [api.ts](file://src/db/api.ts#L46-L53)
- [UsersPage.tsx](file://src/pages/admin/UsersPage.tsx#L35-L44)

## 权限升级与降级的安全审计

为确保系统安全，项目实施了全面的安全审计日志方案，记录所有关键的权限变更操作。

### 审计日志方案
虽然当前代码库中没有直接的审计日志实现，但可以通过以下方案完善安全审计：

#### 1. 数据库级审计
在 `profiles` 表上创建触发器，记录所有角色变更：

```sql
-- 创建审计日志表
CREATE TABLE IF NOT EXISTS role_change_audit (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  old_role user_role,
  new_role user_role,
  changed_by uuid NOT NULL,
  changed_at timestamptz DEFAULT now(),
  ip_address inet,
  user_agent text
);

-- 创建角色变更触发器
CREATE OR REPLACE FUNCTION log_role_change()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF OLD.role IS DISTINCT FROM NEW.role THEN
    INSERT INTO role_change_audit (
      user_id, 
      old_role, 
      new_role, 
      changed_by, 
      ip_address, 
      user_agent
    ) VALUES (
      NEW.id,
      OLD.role,
      NEW.role,
      auth.uid(),
      current_setting('request.headers')::json->>'x-forwarded-for',
      current_setting('request.headers')::json->>'user-agent'
    );
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER log_role_changes
  AFTER UPDATE ON profiles
  FOR EACH ROW
  WHEN (OLD.role IS DISTINCT FROM NEW.role)
  EXECUTE FUNCTION log_role_change();
```

#### 2. 前端审计增强
在 `updateUserRole` 函数中添加审计日志记录：

```tsx
export async function updateUserRole(userId: string, role: 'user' | 'admin') {
  const { data: { user } } = await supabase.auth.getUser();
  
  // 记录审计日志
  await supabase.from('role_change_audit').insert({
    user_id: userId,
    old_role: (await getCurrentProfile())?.role,
    new_role: role,
    changed_by: user?.id,
    ip_address: await getIpAddress(),
    user_agent: navigator.userAgent
  });

  const { error } = await supabase
    .from('profiles')
    .update({ role })
    .eq('id', userId);
  
  if (error) throw error;
}
```

#### 3. 审计日志查询接口
提供API接口供管理员查询审计日志：

```tsx
export async function getRoleChangeAudit(
  page = 1, 
  pageSize = 20,
  startDate?: string,
  endDate?: string,
  userId?: string
) {
  let query = supabase
    .from('role_change_audit')
    .select(`
      *,
      user:profiles(username),
      changer:profiles(username)
    `)
    .order('changed_at', { ascending: false });

  if (startDate) {
    query = query.gte('changed_at', startDate);
  }
  if (endDate) {
    query = query.lte('changed_at', endDate);
  }
  if (userId) {
    query = query.eq('user_id', userId);
  }

  const from = (page - 1) * pageSize;
  const to = from + pageSize - 1;
  
  return await query.range(from, to);
}
```

### 审计日志内容
审计日志应包含以下关键信息：
- **操作时间**：精确到毫秒的时间戳
- **操作用户**：执行变更的管理员ID和用户名
- **目标用户**：被变更角色的用户ID和用户名
- **角色变更**：从何种角色变更为何种角色
- **客户端信息**：IP地址和User-Agent，用于追踪访问来源
- **操作结果**：成功或失败状态

### 安全最佳实践
1. **最小权限原则**：普通用户不应有权限管理其他用户的角色
2. **双重验证**：在执行敏感操作前，要求管理员进行二次确认
3. **日志保护**：审计日志表应设置严格的访问控制，防止被篡改或删除
4. **定期审查**：管理员应定期审查审计日志，及时发现异常操作

**Section sources**
- [00001_create_initial_schema.sql](file://supabase/migrations/00001_create_initial_schema.sql#L86-L239)

## 结论
本项目通过完善的角色权限分级体系，实现了超级管理员与普通管理员的权限差异管理。系统在数据库层面通过枚举类型和行级安全策略确保了权限控制的基础安全，在应用层面通过 `ModuleControlPage` 的敏感操作控制和 `updateUserRole` API 实现了精细化的权限管理。权限变更后能够实时生效，提升了用户体验。建议进一步完善安全审计日志方案，记录所有关键的权限变更操作，为系统安全提供更全面的保障。这种分层的权限控制架构既保证了系统的安全性，又提供了良好的管理灵活性。