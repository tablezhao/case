# 首页趋势概览模块时间范围计算逻辑修复

## 问题分析

### 当前实现逻辑

1. **数据获取**：`getMonthlyAppCountTrend()` 函数从 Supabase 获取所有案件数据，无时间范围限制
2. **前端筛选**：在 `TrendOverviewChart` 组件中根据 `timeRange` 筛选数据

   * **近6个月**：从当前月份往前推6个月，计算起始月份

   * **本年至今**：筛选当前年份的所有月份

   * **全部数据**：返回所有数据

### 错误点

1. **数据获取层面**：总是返回所有历史数据，导致性能问题
2. **前端筛选冗余**：本年至今的筛选条件存在冗余判断
3. **API设计缺陷**：缺少按时间范围获取数据的能力
4. **边界条件处理**：需要确保时间范围计算在年末、年初等特殊情况时准确

## 解决方案设计

### 1. 创建时间范围计算工具函数

* **文件**：`src/utils/timeRangeUtils.ts`

* **功能**：提供准确的时间范围计算逻辑

* **函数**：

  * `calculateTimeRange(timeRange: 'recent6' | 'thisYear' | 'all')`：计算指定时间范围的起始和结束日期

  * `formatMonth(date: Date)`：格式化日期为YYYY-MM格式

### 2. 优化API函数

* **文件**：`src/db/api.ts`

* **修改**：`getMonthlyAppCountTrend()` 函数支持传入时间范围参数

* **实现**：在服务端根据时间范围筛选数据，减少前端数据传输量

### 3. 修正前端筛选逻辑

* **文件**：`src/components/charts/TrendOverviewChart.tsx`

* **简化**：本年至今的筛选条件

* **优化**：确保时间范围计算准确，特别是年末、年初等特殊情况

### 4. 添加单元测试

* **文件**：`src/utils/__tests__/timeRangeUtils.test.ts`

* **覆盖场景**：

  * 正常月份的近6个月计算

  * 年末（12月）的近6个月计算

  * 年初（1月）的近6个月计算

  * 跨年度的近6个月计算

  * 本年至今的计算

  * 全部数据的处理

## 具体实现步骤

### 步骤1：创建时间范围计算工具函数

```typescript
// src/utils/timeRangeUtils.ts
export type TimeRangeType = 'recent6' | 'thisYear' | 'all';

export interface TimeRange {
  startDate: string; // YYYY-MM-DD
  endDate: string;   // YYYY-MM-DD
}

/**
 * 计算时间范围
 * @param timeRange 时间范围类型
 * @returns 起始和结束日期
 */
export function calculateTimeRange(timeRange: TimeRangeType): TimeRange {
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth();
  
  let startDate: Date;
  let endDate = now;
  
  switch (timeRange) {
    case 'recent6':
      // 近6个月：从当前月份起往前推6个月，1号开始
      startDate = new Date(currentYear, currentMonth - 6, 1);
      break;
    case 'thisYear':
      // 本年至今：从当前年份1月1日开始
      startDate = new Date(currentYear, 0, 1);
      break;
    case 'all':
      // 全部数据：起始日期设为1970-01-01，确保包含所有数据
      startDate = new Date(1970, 0, 1);
      break;
  }
  
  return {
    startDate: startDate.toISOString().split('T')[0],
    endDate: endDate.toISOString().split('T')[0]
  };
}

/**
 * 格式化日期为YYYY-MM格式
 * @param date 日期对象
 * @returns 格式化后的月份字符串
 */
export function formatMonth(date: Date): string {
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
}
```

### 步骤2：优化API函数

```typescript
// src/db/api.ts
import { calculateTimeRange } from '@/utils/timeRangeUtils';

export async function getMonthlyAppCountTrend(timeRange?: 'recent6' | 'thisYear' | 'all') {
  let query = supabase.from('cases').select('report_date, app_name');
  
  if (timeRange && timeRange !== 'all') {
    const { startDate, endDate } = calculateTimeRange(timeRange);
    query = query.gte('report_date', startDate).lte('report_date', endDate);
  }

  const { data, error } = await query;
  
  if (error) throw error;
  
  // 按月份分组，统计每月不同的应用数量
  const monthAppSets: Record<string, Set<string>> = {};
  (data || []).forEach(item => {
    const month = item.report_date.substring(0, 7);
    if (!monthAppSets[month]) {
      monthAppSets[month] = new Set();
    }
    if (item.app_name) {
      monthAppSets[month].add(item.app_name);
    }
  });

  return Object.entries(monthAppSets)
    .map(([month, appSet]) => ({ month, count: appSet.size }))
    .sort((a, b) => a.month.localeCompare(b.month));
}
```

### 步骤3：修正前端筛选逻辑

```typescript
// src/components/charts/TrendOverviewChart.tsx
const filteredData = useMemo(() => {
  if (!data || data.length === 0) return [];

  const now = new Date();
  const currentYear = now.getFullYear();

  let filtered = [...data];

  if (timeRange === 'thisYear') {
    // 本年至今：简化筛选条件
    const startOfYearMonth = `${currentYear}-01`;
    filtered = data.filter(item => item.month >= startOfYearMonth);
  }

  // 确保数据按月份排序
  return filtered.sort((a, b) => a.month.localeCompare(b.month));
}, [data, timeRange]);
```

### 步骤4：更新HomePage调用

```typescript
// src/pages/HomePage.tsx
// 当切换时间范围时，重新获取数据
const handleTimeRangeChange = async (range: 'recent6' | 'thisYear' | 'all') => {
  setTrendOverviewRange(range);
  setChartsLoading(true);
  try {
    const monthlyAppCountTrend = await getMonthlyAppCountTrend(range);
    setTrendOverviewData(monthlyAppCountTrend);
  } catch (error) {
    toast.error('获取趋势数据失败');
  } finally {
    setChartsLoading(false);
  }
};
```

### 步骤5：添加单元测试

```typescript
// src/utils/__tests__/timeRangeUtils.test.ts
import { calculateTimeRange, formatMonth } from '../timeRangeUtils';

describe('calculateTimeRange', () => {
  // 模拟当前时间为2025年12月15日
  const mockNow = new Date(2025, 11, 15);
  jest.spyOn(global, 'Date').mockImplementation(() => mockNow as any);
  
  test('should return correct range for recent6 months in December', () => {
    const { startDate, endDate } = calculateTimeRange('recent6');
    expect(startDate).toBe('2025-07-01');
    expect(endDate).toBe('2025-12-15');
  });
  
  test('should return correct range for thisYear in December', () => {
    const { startDate, endDate } = calculateTimeRange('thisYear');
    expect(startDate).toBe('2025-01-01');
    expect(endDate).toBe('2025-12-15');
  });
  
  test('should return correct range for all time', () => {
    const { startDate, endDate } = calculateTimeRange('all');
    expect(startDate).toBe('1970-01-01');
    expect(endDate).toBe('2025-12-15');
  });
  
  // 测试年初情况
  const mockNowJanuary = new Date(2025, 0, 15);
  jest.spyOn(global, 'Date').mockImplementation(() => mockNowJanuary as any);
  
  test('should return correct range for recent6 months in January', () => {
    const { startDate, endDate } = calculateTimeRange('recent6');
    expect(startDate).toBe('2024-08-01');
    expect(endDate).toBe('2025-01-15');
  });
});

describe('formatMonth', () => {
  test('should format date correctly', () => {
    const date = new Date(2025, 6, 15); // 2025年7月15日
    expect(formatMonth(date)).toBe('2025-07');
  });
  
  test('should format January correctly', () => {
    const date = new Date(2025, 0, 15); // 2025年1月15日
    expect(formatMonth(date)).toBe('2025-01');
  });
});
```

## 预期效果

1. **数据准确性**：时间范围计算准确，符合用户要求
2. **性能优化**：服务端筛选数据，减少前端数据传输量
3. **代码可维护性**：时间范围计算逻辑集中管理，便于后续修改
4. **测试覆盖**：单元测试覆盖各种时间场景，确保边界条件处理准确
5. **用户体验**：数据加载更快，响应更及时

## 风险评估

1. **API兼容性**：修改后的API需要确保与现有代码兼容
2. **数据一致性**：需要确保服务端和前端的时间范围计算逻辑一致
3. **测试覆盖**：需要确保所有时间场景都有测试覆盖

## 实施计划

1. 首先创建时间范围计算工具函数和单元测试
2. 然后优化API函数，支持时间范围参数
3. 接着修正前端筛选逻辑
4. 最后更新HomePage调用，实现动态数据获取
5. 运行测试，确保所有功能正常

## 验证标准

1. 近6个月数据：从当前月份往前推6个月，起始日期为当月1号
2. 本年至今数据：从当前年份1月1日开始
3. 全部数据：包含所有历史数据
4. 各种时间场景下的计算结果准确
5. 单元测试通过率100%
   6

